<?php

declare(strict_types=1);

namespace Tests\Keboola\Db\ImportExportFunctional\Snowflake\Exporter;

use Keboola\Db\ImportExport\Backend\Snowflake\Export\S3ParquetExportAdapter;
use Keboola\Db\ImportExport\ExportOptions;
use Keboola\Db\ImportExport\Storage;
use Tests\Keboola\Db\ImportExportFunctional\Snowflake\SnowflakeBaseTestCase;

class ParquetExportTest extends SnowflakeBaseTestCase
{
    public const TESTS_PREFIX = 'parquet_export_test_';

    protected function getTestTableName(): string
    {
        return self::TESTS_PREFIX . uniqid();
    }

    public function setUp(): void
    {
        parent::setUp();
        $this->clearDestination($this->getExportDir());
        $this->cleanSchema($this->getDestinationSchemaName());
        $this->cleanSchema($this->getSourceSchemaName());
        $this->createSchema($this->getSourceSchemaName());
        $this->createSchema($this->getDestinationSchemaName());
    }

    private function createTestTable(string $tableName): void
    {
        $this->connection->executeQuery(sprintf(
            'CREATE TABLE %s (
                "ID" INTEGER,
                "STRING_COL" VARCHAR(255),
                "NUMBER_COL" NUMERIC(10,2),
                "DATE_COL" DATE,
                "BOOL_COL" BOOLEAN
            )',
            $this->connection->quoteIdentifier($tableName),
        ));

        // Insert test data
        $this->connection->executeQuery(sprintf(
            'INSERT INTO %s ("ID", "STRING_COL", "NUMBER_COL", "DATE_COL", "BOOL_COL") VALUES
            (1, \'test string\', 123.45, \'2024-01-01\', true),
            (2, \'another string\', 678.90, \'2024-02-01\', false)',
            $this->connection->quoteIdentifier($tableName),
        ));
    }

    public function testExportSimpleToParquet(): void
    {
        $tableName = $this->getTestTableName();
        $this->createTestTable($tableName);

        $source = new Storage\Snowflake\Table(
            $this->getDestinationSchemaName(),
            $tableName,
        );

        $options = new ExportOptions(
            isCompressed: false,
            generateManifest: ExportOptions::MANIFEST_AUTOGENERATED,
        );
        /** @var Storage\S3\DestinationFile $destination */
        $destination = $this->getDestinationInstance($this->getExportDir() . '/parquet_test');

        $result = (new S3ParquetExportAdapter($this->connection))->runCopyCommand(
            $source,
            $destination,
            $options,
        );

        $this->assertCount(1, $result);
        /** @var array<mixed> $slice */
        $slice = reset($result);

        $this->assertArrayHasKey('FILE_NAME', $slice);
        $this->assertArrayHasKey('FILE_SIZE', $slice);
        $this->assertArrayHasKey('ROW_COUNT', $slice);

        $this->assertStringEndsWith('.parquet', $slice['FILE_NAME']);
        $this->assertNotEmpty($slice['FILE_SIZE']);
        $this->assertSame(2, (int) $slice['ROW_COUNT']);

        $files = $this->getFileNames($this->getExportDir(), false);
        $this->assertContains($this->getExportDir() . '/parquet_testmanifest', array_values($files));
        $stageName = $this->prepareStage($destination);
        [$data, $newTableName] = $this->loadDataFromStageToSnowflakeTable($tableName, $stageName, $slice['FILE_NAME']);

        $this->assertCount(2, $data);

        // Check first row
        $this->assertEquals(1, (int) $data[0]['ID']);
        $this->assertEquals('test string', $data[0]['STRING_COL']);
        $this->assertEquals('123.45', $data[0]['NUMBER_COL']);
        $this->assertEquals('2024-01-01', $data[0]['DATE_COL']);
        $this->assertEquals('1', $data[0]['BOOL_COL']); // Snowflake returns booleans as '1'/'0'

        // Check second row
        $this->assertEquals(2, (int) $data[1]['ID']);
        $this->assertEquals('another string', $data[1]['STRING_COL']);
        $this->assertEquals('678.90', $data[1]['NUMBER_COL']);
        $this->assertEquals('2024-02-01', $data[1]['DATE_COL']);
        $this->assertEquals('0', $data[1]['BOOL_COL']);

        // Clean up
        $this->connection->executeQuery(sprintf(
            'DROP STAGE IF EXISTS %s',
            $this->connection->quoteIdentifier($stageName),
        ));
        $this->connection->executeQuery(sprintf(
            'DROP TABLE IF EXISTS %s',
            $this->connection->quoteIdentifier($newTableName),
        ));
    }

    public function testExportCompressedParquet(): void
    {
        $tableName = $this->getTestTableName();
        $this->createTestTable($tableName);

        $source = new Storage\Snowflake\SelectSource(sprintf(
            'SELECT * FROM %s',
            $this->connection->quoteIdentifier($tableName),
        ));

        $options = new ExportOptions(
            isCompressed: true,
            generateManifest: ExportOptions::MANIFEST_AUTOGENERATED,
        );
        /** @var Storage\S3\DestinationFile $destination */
        $destination = $this->getDestinationInstance($this->getExportDir() . '/parquet_compressed_test');

        $result = (new S3ParquetExportAdapter($this->connection))->runCopyCommand(
            $source,
            $destination,
            $options,
        );

        $this->assertCount(1, $result);
        /** @var array<mixed> $slice */
        $slice = reset($result);

        $this->assertArrayHasKey('FILE_NAME', $slice);
        $this->assertArrayHasKey('FILE_SIZE', $slice);
        $this->assertArrayHasKey('ROW_COUNT', $slice);

        $this->assertStringEndsWith('.parquet', $slice['FILE_NAME']);
        $this->assertNotEmpty($slice['FILE_SIZE']);
        $this->assertSame(2, (int) $slice['ROW_COUNT']);

        $files = $this->getFileNames($this->getExportDir(), false);
        $this->assertContains($this->getExportDir() . '/parquet_compressed_testmanifest', array_values($files));

        $stageName = $this->prepareStage($destination);
        [$data, $newTableName] = $this->loadDataFromStageToSnowflakeTable($tableName, $stageName, $slice['FILE_NAME']);

        $this->assertCount(2, $data);

        // Check first row
        $this->assertEquals(1, (int) $data[0]['ID']);
        $this->assertEquals('test string', $data[0]['STRING_COL']);
        $this->assertEquals('123.45', $data[0]['NUMBER_COL']);
        $this->assertEquals('2024-01-01', $data[0]['DATE_COL']);
        $this->assertEquals('1', $data[0]['BOOL_COL']); // Snowflake returns booleans as '1'/'0'

        // Check second row
        $this->assertEquals(2, (int) $data[1]['ID']);
        $this->assertEquals('another string', $data[1]['STRING_COL']);
        $this->assertEquals('678.90', $data[1]['NUMBER_COL']);
        $this->assertEquals('2024-02-01', $data[1]['DATE_COL']);
        $this->assertEquals('0', $data[1]['BOOL_COL']);

        // Clean up
        $this->connection->executeQuery(sprintf(
            'DROP STAGE IF EXISTS %s',
            $this->connection->quoteIdentifier($stageName),
        ));
        $this->connection->executeQuery(sprintf(
            'DROP TABLE IF EXISTS %s',
            $this->connection->quoteIdentifier($newTableName),
        ));
    }

    public function testExportParquetWithQuery(): void
    {
        $tableName = $this->getTestTableName();
        $this->createTestTable($tableName);

        // Use a query that transforms the data
        $source = new Storage\Snowflake\SelectSource(sprintf(
            'SELECT * FROM %s',
            $this->connection->quoteIdentifier($tableName),
        ));

        $options = new ExportOptions(
            isCompressed: false,
            generateManifest: ExportOptions::MANIFEST_AUTOGENERATED,
        );
        /** @var Storage\S3\DestinationFile $destination */
        $destination = $this->getDestinationInstance($this->getExportDir() . '/parquet_query_test');

        $result = (new S3ParquetExportAdapter($this->connection))->runCopyCommand(
            $source,
            $destination,
            $options,
        );

        $this->assertCount(1, $result);
        /** @var array<mixed> $slice */
        $slice = reset($result);

        $this->assertArrayHasKey('FILE_NAME', $slice);
        $this->assertArrayHasKey('FILE_SIZE', $slice);
        $this->assertArrayHasKey('ROW_COUNT', $slice);

        $this->assertStringEndsWith('.parquet', $slice['FILE_NAME']);
        $this->assertNotEmpty($slice['FILE_SIZE']);
        $this->assertSame(2, (int) $slice['ROW_COUNT']);

        $files = $this->getFileNames($this->getExportDir(), false);
        $this->assertContains($this->getExportDir() . '/parquet_query_testmanifest', array_values($files));

        $stageName = $this->prepareStage($destination);
        [$data, $newTableName] = $this->loadDataFromStageToSnowflakeTable($tableName, $stageName, $slice['FILE_NAME']);

        $this->assertCount(2, $data);

        // Check first row
        $this->assertEquals(1, (int) $data[0]['ID']);
        $this->assertEquals('test string', $data[0]['STRING_COL']);
        $this->assertEquals('123.45', $data[0]['NUMBER_COL']);
        $this->assertEquals('2024-01-01', $data[0]['DATE_COL']);
        $this->assertEquals('1', $data[0]['BOOL_COL']); // Snowflake returns booleans as '1'/'0'

        // Check second row
        $this->assertEquals(2, (int) $data[1]['ID']);
        $this->assertEquals('another string', $data[1]['STRING_COL']);
        $this->assertEquals('678.90', $data[1]['NUMBER_COL']);
        $this->assertEquals('2024-02-01', $data[1]['DATE_COL']);
        $this->assertEquals('0', $data[1]['BOOL_COL']);

        // Clean up
        $this->connection->executeQuery(sprintf(
            'DROP STAGE IF EXISTS %s',
            $this->connection->quoteIdentifier($stageName),
        ));
        $this->connection->executeQuery(sprintf(
            'DROP TABLE IF EXISTS %s',
            $this->connection->quoteIdentifier($newTableName),
        ));
    }

    private function prepareStage(Storage\S3\DestinationFile $destination): string
    {
        // Create a stage for the exported Parquet file
        $stageName = sprintf('PARQUET_TEST_STAGE_%s', uniqid());

        $quotedStageName = $this->connection->quoteIdentifier($stageName);
        $quotedUrl = $this->connection->quote($destination->getS3Prefix() . '/' . $this->getExportDir());
        $quotedKey = $this->connection->quote($destination->getKey());
        $quotedSecret = $this->connection->quote($destination->getSecret());
        assert(is_string($quotedStageName));
        assert(is_string($quotedUrl));
        assert(is_string($quotedKey));
        assert(is_string($quotedSecret));

        $this->connection->executeQuery(sprintf(
            'CREATE OR REPLACE STAGE %s
            URL = %s
            CREDENTIALS = (AWS_KEY_ID = %s AWS_SECRET_KEY = %s)
            FILE_FORMAT = (TYPE = PARQUET)',
            $quotedStageName,
            $quotedUrl,
            $quotedKey,
            $quotedSecret,
        ));

        return $stageName;
    }

    /**
     * @return array{0: array<int, array<string, string|int>>, 1: non-empty-string}
     */
    private function loadDataFromStageToSnowflakeTable(string $tableName, string $stageName, string $fileName): array
    {
        // Create a new table directly from the stage, letting Snowflake infer the schema
        $newTableName = sprintf('%s_from_parquet', $tableName);
        $this->connection->executeQuery(sprintf(
            'CREATE OR REPLACE TABLE %s AS
            SELECT * FROM @%s/%s',
            $this->connection->quoteIdentifier($newTableName),
            $this->connection->quoteIdentifier($stageName),
            basename($fileName),
        ));

        // Verify the data structure and values
        /** @var array<int, array<string, string|int>> $data */
        $data = $this->connection->fetchAllAssociative(sprintf(
            'SELECT 
                PARSE_JSON($1):"ID"::INTEGER as "ID",
                PARSE_JSON($1):"STRING_COL"::VARCHAR as "STRING_COL",
                PARSE_JSON($1):"NUMBER_COL"::NUMERIC(10,2) as "NUMBER_COL",
                PARSE_JSON($1):"DATE_COL"::DATE as "DATE_COL",
                PARSE_JSON($1):"BOOL_COL"::BOOLEAN as "BOOL_COL"
            FROM %s ORDER BY PARSE_JSON($1):"ID"::INTEGER',
            $this->connection->quoteIdentifier($newTableName),
        ));
        return [$data, $newTableName];
    }
}
